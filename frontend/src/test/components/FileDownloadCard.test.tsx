/**
 * Tests for FileDownloadCard Component (Feature 008)
 *
 * Tests the file download card component that displays downloadable
 * files generated by formatter agents.
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import FileDownloadCard, { FileInfo } from '../../components/Chat/FileDownloadCard'

// Mock fetch globally
const mockFetch = vi.fn()
global.fetch = mockFetch

// Mock URL.createObjectURL and revokeObjectURL
const mockCreateObjectURL = vi.fn(() => 'blob:mock-url')
const mockRevokeObjectURL = vi.fn()
global.URL.createObjectURL = mockCreateObjectURL
global.URL.revokeObjectURL = mockRevokeObjectURL

// Helper function to create test file info
function createTestFileInfo(overrides: Partial<FileInfo> = {}): FileInfo {
  return {
    file_id: 'test-file-123',
    filename: 'genes_20250107T123456Z.csv',
    format: 'csv',
    size_bytes: 1024,
    mime_type: 'text/csv',
    download_url: '/api/files/test-file-123/download',
    created_at: '2025-01-07T12:34:56Z',
    ...overrides
  }
}

describe('FileDownloadCard - Basic Rendering', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders file card with filename', () => {
    const fileInfo = createTestFileInfo()
    render(<FileDownloadCard file={fileInfo} />)

    expect(screen.getByText('genes_20250107T123456Z.csv')).toBeInTheDocument()
  })

  it('renders format badge for CSV', () => {
    const fileInfo = createTestFileInfo({ format: 'csv' })
    render(<FileDownloadCard file={fileInfo} />)

    expect(screen.getByText('CSV')).toBeInTheDocument()
  })

  it('renders format badge for TSV', () => {
    const fileInfo = createTestFileInfo({ format: 'tsv', filename: 'data.tsv' })
    render(<FileDownloadCard file={fileInfo} />)

    expect(screen.getByText('TSV')).toBeInTheDocument()
  })

  it('renders format badge for JSON', () => {
    const fileInfo = createTestFileInfo({ format: 'json', filename: 'data.json' })
    render(<FileDownloadCard file={fileInfo} />)

    expect(screen.getByText('JSON')).toBeInTheDocument()
  })

  it('renders file size when provided', () => {
    const fileInfo = createTestFileInfo({ size_bytes: 2048 })
    render(<FileDownloadCard file={fileInfo} />)

    expect(screen.getByText('2.0 KB')).toBeInTheDocument()
  })

  it('renders file size in MB for large files', () => {
    const fileInfo = createTestFileInfo({ size_bytes: 1.5 * 1024 * 1024 })
    render(<FileDownloadCard file={fileInfo} />)

    expect(screen.getByText('1.5 MB')).toBeInTheDocument()
  })

  it('does not render size when not provided', () => {
    const fileInfo = createTestFileInfo({ size_bytes: undefined })
    render(<FileDownloadCard file={fileInfo} />)

    // Should not have any KB/MB text
    expect(screen.queryByText(/KB|MB|B$/)).not.toBeInTheDocument()
  })

  it('renders download button', () => {
    const fileInfo = createTestFileInfo()
    render(<FileDownloadCard file={fileInfo} />)

    expect(screen.getByRole('button')).toBeInTheDocument()
  })
})

describe('FileDownloadCard - Download Functionality', () => {
  let mockLink: HTMLAnchorElement
  let mockAppendChild: ReturnType<typeof vi.spyOn>
  let mockRemoveChild: ReturnType<typeof vi.spyOn>

  beforeEach(() => {
    vi.clearAllMocks()

    // Mock the anchor element
    mockLink = {
      href: '',
      download: '',
      click: vi.fn(),
    } as unknown as HTMLAnchorElement

    vi.spyOn(document, 'createElement').mockReturnValue(mockLink)
    mockAppendChild = vi.spyOn(document.body, 'appendChild').mockReturnValue(mockLink)
    mockRemoveChild = vi.spyOn(document.body, 'removeChild').mockReturnValue(mockLink)
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  it('initiates download on button click', async () => {
    const fileInfo = createTestFileInfo()
    const mockBlob = new Blob(['test data'], { type: 'text/csv' })

    mockFetch.mockResolvedValueOnce({
      ok: true,
      blob: () => Promise.resolve(mockBlob),
    })

    render(<FileDownloadCard file={fileInfo} />)

    fireEvent.click(screen.getByRole('button'))

    await waitFor(() => {
      expect(mockFetch).toHaveBeenCalledWith(
        '/api/files/test-file-123/download',
        { credentials: 'include' }
      )
    })
  })

  it('creates download link with correct filename', async () => {
    const fileInfo = createTestFileInfo({ filename: 'my_export.csv' })
    const mockBlob = new Blob(['test data'], { type: 'text/csv' })

    mockFetch.mockResolvedValueOnce({
      ok: true,
      blob: () => Promise.resolve(mockBlob),
    })

    render(<FileDownloadCard file={fileInfo} />)

    fireEvent.click(screen.getByRole('button'))

    await waitFor(() => {
      expect(mockLink.download).toBe('my_export.csv')
      expect(mockLink.click).toHaveBeenCalled()
    })
  })

  it('shows loading state during download', async () => {
    const fileInfo = createTestFileInfo()

    // Create a promise that we can resolve manually
    let resolveDownload: (value: unknown) => void
    const downloadPromise = new Promise(resolve => {
      resolveDownload = resolve
    })

    mockFetch.mockReturnValueOnce(downloadPromise)

    render(<FileDownloadCard file={fileInfo} />)

    fireEvent.click(screen.getByRole('button'))

    // Button should be disabled while loading
    expect(screen.getByRole('button')).toBeDisabled()

    // Resolve the download
    resolveDownload!({
      ok: true,
      blob: () => Promise.resolve(new Blob(['data'])),
    })

    await waitFor(() => {
      expect(screen.getByRole('button')).not.toBeDisabled()
    })
  })

  it('shows error message on download failure', async () => {
    const fileInfo = createTestFileInfo()

    mockFetch.mockResolvedValueOnce({
      ok: false,
      statusText: 'Not Found',
      json: () => Promise.resolve({ detail: 'File not found' }),
    })

    render(<FileDownloadCard file={fileInfo} />)

    fireEvent.click(screen.getByRole('button'))

    await waitFor(() => {
      expect(screen.getByText('File not found')).toBeInTheDocument()
    })
  })

  it('shows generic error on network failure', async () => {
    const fileInfo = createTestFileInfo()

    mockFetch.mockRejectedValueOnce(new Error('Network error'))

    render(<FileDownloadCard file={fileInfo} />)

    fireEvent.click(screen.getByRole('button'))

    await waitFor(() => {
      expect(screen.getByText('Network error')).toBeInTheDocument()
    })
  })

  it('cleans up blob URL after download', async () => {
    const fileInfo = createTestFileInfo()
    const mockBlob = new Blob(['test data'], { type: 'text/csv' })

    mockFetch.mockResolvedValueOnce({
      ok: true,
      blob: () => Promise.resolve(mockBlob),
    })

    render(<FileDownloadCard file={fileInfo} />)

    fireEvent.click(screen.getByRole('button'))

    await waitFor(() => {
      expect(mockRevokeObjectURL).toHaveBeenCalledWith('blob:mock-url')
    })
  })
})

describe('FileDownloadCard - File Size Formatting', () => {
  it('formats bytes correctly', () => {
    const fileInfo = createTestFileInfo({ size_bytes: 512 })
    render(<FileDownloadCard file={fileInfo} />)

    expect(screen.getByText('512 B')).toBeInTheDocument()
  })

  it('formats kilobytes correctly', () => {
    const fileInfo = createTestFileInfo({ size_bytes: 1536 })
    render(<FileDownloadCard file={fileInfo} />)

    expect(screen.getByText('1.5 KB')).toBeInTheDocument()
  })

  it('formats megabytes correctly', () => {
    const fileInfo = createTestFileInfo({ size_bytes: 2.5 * 1024 * 1024 })
    render(<FileDownloadCard file={fileInfo} />)

    expect(screen.getByText('2.5 MB')).toBeInTheDocument()
  })
})
