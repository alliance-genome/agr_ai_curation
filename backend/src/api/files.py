"""File output API endpoints for file management and downloads.

Provides endpoints for:
- Recording files generated by file output agents
- Downloading files with audit trail
- Listing files for a session

All endpoints require authentication via AWS Cognito JWT tokens.
"""

import logging
from datetime import datetime, timezone
from pathlib import Path
from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query
from fastapi.responses import FileResponse
from sqlalchemy import func
from sqlalchemy.orm import Session

from src.api.auth import get_auth_dependency
from src.lib.file_outputs.storage import FileOutputStorageService, PathSecurityError
from src.models.sql.database import get_db
from src.models.sql.file_output import FileOutput
from src.schemas.file_output import (
    FileOutputCreate,
    FileOutputListResponse,
    FileOutputResponse,
)

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/files", tags=["files"])

# Content-Type mapping for file downloads
CONTENT_TYPE_MAP = {
    "csv": "text/csv",
    "tsv": "text/tab-separated-values",
    "json": "application/json",
}

# Max file size (100 MB)
MAX_FILE_SIZE = 100 * 1024 * 1024


def _get_curator_id(user: dict) -> str:
    """Extract curator ID from authenticated user.

    Uses 'sub' claim which is the unique Cognito user ID.
    """
    return user.get("sub") or user.get("uid", "unknown")


def _verify_session_ownership(
    db: Session, session_id: str, curator_id: str
) -> None:
    """Verify the user owns files in this session.

    Since files are created with curator_id, we check if any files
    in this session belong to a different curator.

    Raises:
        HTTPException: 403 if session belongs to another user
    """
    # Check if there are any files in this session by other users
    other_user_file = (
        db.query(FileOutput)
        .filter(FileOutput.session_id == session_id)
        .filter(FileOutput.curator_id != curator_id)
        .first()
    )

    if other_user_file:
        logger.warning(
            f"User {curator_id} attempted to access session {session_id} "
            f"owned by {other_user_file.curator_id}"
        )
        raise HTTPException(
            status_code=403,
            detail="Not authorized to access files from this session",
        )


def _build_download_url(file_id: UUID) -> str:
    """Build the download URL for a file."""
    return f"/api/files/{file_id}/download"


def _file_to_response(file: FileOutput) -> FileOutputResponse:
    """Convert FileOutput model to response schema."""
    return FileOutputResponse(
        id=file.id,
        filename=file.filename,
        file_type=file.file_type,
        file_size=file.file_size,
        curator_id=file.curator_id,
        session_id=file.session_id,
        trace_id=file.trace_id,
        download_count=file.download_count,
        created_at=file.created_at,
        download_url=_build_download_url(file.id),
    )


@router.post("/record", response_model=FileOutputResponse, status_code=201)
def record_file(
    data: FileOutputCreate,
    db: Annotated[Session, Depends(get_db)],
    user: dict = get_auth_dependency(),
) -> FileOutputResponse:
    """Record a newly generated file.

    Called by file output agents after generating a file to disk.
    Creates a database record linking the file to its trace for audit.

    Args:
        data: File output creation data
        db: Database session
        user: Authenticated user from Cognito

    Returns:
        FileOutputResponse with file metadata and download URL

    Raises:
        400: Invalid input (validation failure)
        401: Missing or invalid authentication
        409: File already exists at path
    """
    curator_id = _get_curator_id(user)

    # Verify file size within limits
    if data.file_size > MAX_FILE_SIZE:
        raise HTTPException(
            status_code=400,
            detail=f"File size exceeds maximum allowed ({MAX_FILE_SIZE:,} bytes)",
        )

    # Check for duplicate file_path
    existing = (
        db.query(FileOutput).filter(FileOutput.file_path == data.file_path).first()
    )
    if existing:
        raise HTTPException(
            status_code=409,
            detail=f"File already recorded at path: {data.file_path}",
        )

    # Verify the file actually exists on disk (security check)
    storage = FileOutputStorageService()
    # file_path in data is the full path from storage service
    # We need to extract relative path for storage lookup
    try:
        base_path = storage.base_path.resolve()
        file_path = Path(data.file_path).resolve()
        if not file_path.is_relative_to(base_path):
            raise HTTPException(
                status_code=400,
                detail="File path is not within allowed storage directory",
            )
    except (ValueError, PathSecurityError):
        raise HTTPException(
            status_code=400,
            detail="Invalid file path",
        )

    if not file_path.exists():
        raise HTTPException(
            status_code=400,
            detail="File does not exist at specified path",
        )

    logger.info(
        f"Recording file: {data.filename} (type={data.file_type}, "
        f"size={data.file_size}, trace={data.trace_id})"
    )

    # Create database record
    file_output = FileOutput(
        filename=data.filename,
        file_path=data.file_path,
        file_type=data.file_type,
        file_size=data.file_size,
        file_hash=data.file_hash,
        curator_id=curator_id,
        session_id=data.session_id,
        trace_id=data.trace_id,
        agent_name=data.agent_name,
        generation_model=data.generation_model,
        file_metadata=data.file_metadata,
    )

    db.add(file_output)
    db.commit()
    db.refresh(file_output)

    logger.info(f"Recorded file output: {file_output.id}")

    return _file_to_response(file_output)


@router.get("/{file_id}", response_model=FileOutputResponse)
def get_file_metadata(
    file_id: UUID,
    db: Annotated[Session, Depends(get_db)],
    user: dict = get_auth_dependency(),
) -> FileOutputResponse:
    """Get file metadata.

    Args:
        file_id: UUID of the file
        db: Database session
        user: Authenticated user from Cognito

    Returns:
        FileOutputResponse with file metadata and download URL

    Raises:
        401: Missing or invalid authentication
        403: Not authorized to access this file
        404: File not found
    """
    curator_id = _get_curator_id(user)

    file = db.query(FileOutput).filter(FileOutput.id == file_id).first()

    if not file:
        raise HTTPException(status_code=404, detail="File not found")

    # Verify ownership
    if file.curator_id != curator_id:
        logger.warning(
            f"User {curator_id} attempted to access file {file_id} "
            f"owned by {file.curator_id}"
        )
        raise HTTPException(
            status_code=403,
            detail="Not authorized to access this file",
        )

    return _file_to_response(file)


@router.get("/{file_id}/download")
def download_file(
    file_id: UUID,
    db: Annotated[Session, Depends(get_db)],
    user: dict = get_auth_dependency(),
) -> FileResponse:
    """Download the actual file.

    Updates download metrics (count, timestamps) on each download.

    Args:
        file_id: UUID of the file
        db: Database session
        user: Authenticated user from Cognito

    Returns:
        FileResponse with file content

    Raises:
        401: Missing or invalid authentication
        403: Not authorized to access this file
        404: File not found or file missing from disk
    """
    curator_id = _get_curator_id(user)

    file = db.query(FileOutput).filter(FileOutput.id == file_id).first()

    if not file:
        raise HTTPException(status_code=404, detail="File not found")

    # Verify ownership
    if file.curator_id != curator_id:
        logger.warning(
            f"User {curator_id} attempted to download file {file_id} "
            f"owned by {file.curator_id}"
        )
        raise HTTPException(
            status_code=403,
            detail="Not authorized to access this file",
        )

    # Verify file exists on disk and is within storage directory
    storage = FileOutputStorageService()
    file_path = Path(file.file_path)
    try:
        resolved_path = file_path.resolve()
        base_path = storage.base_path.resolve()
        if not resolved_path.is_relative_to(base_path):
            logger.error(f"Path traversal attempt: {file.file_path}")
            raise HTTPException(
                status_code=404,
                detail="File not found on storage",
            )
    except (ValueError, PathSecurityError):
        logger.error(f"Invalid file path: {file.file_path}")
        raise HTTPException(
            status_code=404,
            detail="File not found on storage",
        )

    if not file_path.exists():
        logger.error(f"File missing from disk: {file.file_path}")
        raise HTTPException(
            status_code=404,
            detail="File not found on storage",
        )

    # Update download metrics
    now = datetime.now(timezone.utc)
    file.download_count += 1
    file.last_download_at = now
    db.commit()

    logger.info(
        f"Downloading file: {file.id} ({file.filename}) - "
        f"download #{file.download_count}"
    )

    # Get content type
    content_type = CONTENT_TYPE_MAP.get(file.file_type, "application/octet-stream")

    # Sanitize filename for Content-Disposition header (prevent header injection)
    # Remove characters that could break HTTP headers or enable injection
    safe_filename = (
        file.filename
        .replace('"', "'")  # Replace double quotes with single quotes
        .replace("\r", "")  # Remove carriage returns
        .replace("\n", "")  # Remove newlines
        .replace("\x00", "")  # Remove null bytes
    )

    return FileResponse(
        path=file_path,
        filename=safe_filename,
        media_type=content_type,
        headers={
            "Content-Disposition": f'attachment; filename="{safe_filename}"',
        },
    )


@router.get("/session/{session_id}", response_model=FileOutputListResponse)
def list_session_files(
    session_id: str,
    db: Annotated[Session, Depends(get_db)],
    user: dict = get_auth_dependency(),
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(20, ge=1, le=100, description="Items per page"),
    file_type: str | None = Query(None, pattern="^(csv|tsv|json)$", description="Filter by type"),
) -> FileOutputListResponse:
    """List all files for a session.

    Returns paginated list of files belonging to the authenticated user's session.

    Args:
        session_id: Session identifier
        db: Database session
        user: Authenticated user from Cognito
        page: Page number (default: 1)
        page_size: Items per page (default: 20, max: 100)
        file_type: Optional filter by file type (csv, tsv, json)

    Returns:
        FileOutputListResponse with paginated file list

    Raises:
        401: Missing or invalid authentication
        403: Not authorized to access files from this session
    """
    curator_id = _get_curator_id(user)

    # Verify session ownership
    _verify_session_ownership(db, session_id, curator_id)

    # Build query
    query = db.query(FileOutput).filter(
        FileOutput.session_id == session_id,
        FileOutput.curator_id == curator_id,
    )

    if file_type:
        query = query.filter(FileOutput.file_type == file_type)

    # Get total count
    total_count = query.count()

    # Apply pagination
    offset = (page - 1) * page_size
    files = query.order_by(FileOutput.created_at.desc()).offset(offset).limit(page_size).all()

    return FileOutputListResponse(
        items=[_file_to_response(f) for f in files],
        total_count=total_count,
        page=page,
        page_size=page_size,
    )
