"""
Agent Definition Loader for Config-Driven Architecture.

This module discovers and loads agent definitions from YAML files in the
config/agents/ directory. Each agent folder contains:
- agent.yaml: Agent metadata and configuration
- prompt.yaml: Base prompt template
- schema.py: Pydantic output schema (optional)
- group_rules/: Organization-specific rules (optional)

Usage:
    from src.lib.config import load_agent_definitions, get_agent_definition

    # Load all agents at startup
    agents = load_agent_definitions()

    # Get a specific agent
    gene_agent = get_agent_definition("gene_validation")
"""

import logging
import os
import threading
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional, Any

import yaml

logger = logging.getLogger(__name__)


def _find_project_root() -> Optional[Path]:
    """Find project root by looking for pyproject.toml or docker-compose.yml.

    This is more robust than counting parent directories, which breaks if
    the module is moved.

    Returns:
        Path to project root directory, or None if not found
    """
    current = Path(__file__).resolve()
    for parent in [current] + list(current.parents):
        if (parent / "pyproject.toml").exists() or (parent / "docker-compose.yml").exists():
            return parent
    return None


def _get_default_agents_path() -> Path:
    """Get the default agents path, trying multiple strategies.

    Order of precedence:
    1. AGENTS_CONFIG_PATH environment variable
    2. Project root detection (pyproject.toml or docker-compose.yml)
    3. Relative path from this module (fallback for Docker)

    Returns:
        Path to agents directory
    """
    # Strategy 1: Environment variable
    env_path = os.environ.get("AGENTS_CONFIG_PATH")
    if env_path:
        return Path(env_path)

    # Strategy 2: Project root detection
    project_root = _find_project_root()
    if project_root:
        return project_root / "config" / "agents"

    # Strategy 3: Relative path fallback (for Docker where backend is at /app/backend)
    # backend/src/lib/config/agent_loader.py -> /app/backend -> /app/config/agents
    return Path(__file__).parent.parent.parent.parent.parent / "config" / "agents"


# Default path for agent configurations (can be overridden)
DEFAULT_AGENTS_PATH = _get_default_agents_path()

# Thread safety lock for initialization
_init_lock = threading.Lock()


@dataclass
class SupervisorRouting:
    """Configuration for how the supervisor routes to this agent.

    Note: The supervisor tool name (e.g., ask_gene_specialist) is NOT stored here.
    It is generated by AgentDefinition.tool_name based on the folder name.
    """

    enabled: bool = True
    description: str = ""
    batchable: bool = False
    batching_instructions: str = ""


@dataclass
class ModelConfig:
    """LLM configuration for the agent."""

    model: str = "gpt-4o"
    temperature: float = 0.1
    reasoning: str = "medium"


@dataclass
class FrontendConfig:
    """Frontend display configuration."""

    icon: str = "ğŸ¤–"
    show_in_palette: bool = True


@dataclass
class AgentDefinition:
    """
    Complete agent definition loaded from agent.yaml.

    Attributes:
        folder_name: The folder name (e.g., "gene", "allele")
        agent_id: Unique identifier (e.g., "gene_validation")
        name: Human-readable name
        description: Brief description of agent capabilities
        category: Agent category (e.g., "Validation", "Extraction")
        subcategory: Agent subcategory
        supervisor_routing: Routing configuration for supervisor
        tools: List of tool names this agent can use
        output_schema: Name of Pydantic schema class (or None)
        model_config: LLM settings
        requires_document: Whether agent needs a loaded document
        required_params: List of required parameter names
        batch_capabilities: List of batch operation types supported
        group_rules_enabled: Whether to inject group-specific rules
        frontend: Frontend display settings
        tool_name: Generated supervisor tool name (ask_{folder}_specialist)
    """

    folder_name: str
    agent_id: str
    name: str
    description: str = ""
    category: str = ""
    subcategory: str = ""
    supervisor_routing: SupervisorRouting = field(default_factory=SupervisorRouting)
    tools: List[str] = field(default_factory=list)
    output_schema: Optional[str] = None
    model_config: ModelConfig = field(default_factory=ModelConfig)
    requires_document: bool = False
    required_params: List[str] = field(default_factory=list)
    batch_capabilities: List[str] = field(default_factory=list)
    group_rules_enabled: bool = False
    frontend: FrontendConfig = field(default_factory=FrontendConfig)

    @property
    def tool_name(self) -> str:
        """Generate supervisor tool name from folder name."""
        return f"ask_{self.folder_name}_specialist"

    @classmethod
    def from_yaml(cls, folder_name: str, data: Dict[str, Any]) -> "AgentDefinition":
        """
        Create an AgentDefinition from parsed YAML data.

        Args:
            folder_name: Name of the agent folder
            data: Parsed YAML dictionary

        Returns:
            AgentDefinition instance
        """
        # Parse supervisor_routing
        routing_data = data.get("supervisor_routing", {})
        supervisor_routing = SupervisorRouting(
            enabled=routing_data.get("enabled", True),
            description=routing_data.get("description", "").strip(),
            batchable=routing_data.get("batchable", False),
            batching_instructions=routing_data.get("batching_instructions", "").strip(),
        )

        # Parse model_config with environment variable substitution
        model_data = data.get("model_config", {})
        model_str = model_data.get("model", "gpt-4o")
        # Handle ${VAR:-default} syntax
        if model_str.startswith("${") and ":-" in model_str:
            # Parse ${AGENT_GENE_MODEL:-gpt-4o} -> check env var, else use default
            var_part = model_str[2:]  # Remove ${
            var_name, default_val = var_part.split(":-", 1)
            default_val = default_val.rstrip("}")
            model_str = os.environ.get(var_name, default_val)
        model_config = ModelConfig(
            model=model_str,
            temperature=model_data.get("temperature", 0.1),
            reasoning=model_data.get("reasoning", "medium"),
        )

        # Parse frontend config
        frontend_data = data.get("frontend", {})
        frontend = FrontendConfig(
            icon=frontend_data.get("icon", "ğŸ¤–"),
            show_in_palette=frontend_data.get("show_in_palette", True),
        )

        return cls(
            folder_name=folder_name,
            agent_id=data.get("agent_id", folder_name),
            name=data.get("name", folder_name.replace("_", " ").title()),
            description=data.get("description", "").strip(),
            category=data.get("category", ""),
            subcategory=data.get("subcategory", ""),
            supervisor_routing=supervisor_routing,
            tools=data.get("tools", []),
            output_schema=data.get("output_schema"),
            model_config=model_config,
            requires_document=data.get("requires_document", False),
            required_params=data.get("required_params", []),
            batch_capabilities=data.get("batch_capabilities", []),
            group_rules_enabled=data.get("group_rules_enabled", False),
            frontend=frontend,
        )


# Module-level cache for loaded agents
_agent_registry: Dict[str, AgentDefinition] = {}
_agents_by_folder: Dict[str, AgentDefinition] = {}
_initialized: bool = False


def load_agent_definitions(
    agents_path: Optional[Path] = None,
    force_reload: bool = False,
) -> Dict[str, AgentDefinition]:
    """
    Discover and load all agent definitions from YAML files.

    Scans the agents directory for folders containing agent.yaml files.
    Folders starting with underscore (_) are skipped (e.g., _examples/).

    This function is thread-safe; concurrent calls will block until
    initialization is complete.

    Args:
        agents_path: Path to agents directory (default: config/agents/)
        force_reload: Force reload even if already initialized

    Returns:
        Dictionary mapping agent_id to AgentDefinition

    Raises:
        FileNotFoundError: If agents_path doesn't exist
        yaml.YAMLError: If YAML parsing fails
    """
    global _agent_registry, _agents_by_folder, _initialized

    # Thread-safe initialization
    with _init_lock:
        if _initialized and not force_reload:
            return _agent_registry

        if agents_path is None:
            agents_path = DEFAULT_AGENTS_PATH

        if not agents_path.exists():
            raise FileNotFoundError(f"Agents directory not found: {agents_path}")

        logger.info(f"Loading agent definitions from: {agents_path}")

        _agent_registry = {}
        _agents_by_folder = {}

        # Scan for agent folders
        for folder in sorted(agents_path.iterdir()):
            # Skip non-directories and underscore-prefixed folders
            if not folder.is_dir() or folder.name.startswith("_"):
                continue

            agent_yaml = folder / "agent.yaml"
            if not agent_yaml.exists():
                logger.debug(f"Skipping {folder.name}: no agent.yaml found")
                continue

            try:
                with open(agent_yaml, "r") as f:
                    data = yaml.safe_load(f)

                if not data:
                    logger.warning(f"Empty agent.yaml in {folder.name}")
                    continue

                agent = AgentDefinition.from_yaml(folder.name, data)
                _agent_registry[agent.agent_id] = agent
                _agents_by_folder[folder.name] = agent

                logger.info(
                    f"Loaded agent: {agent.agent_id} "
                    f"(folder={folder.name}, tool={agent.tool_name})"
                )

            except yaml.YAMLError as e:
                logger.error(f"Failed to parse {agent_yaml}: {e}")
                raise
            except Exception as e:
                logger.error(f"Failed to load agent from {folder.name}: {e}")
                raise

        _initialized = True
        logger.info(f"Loaded {len(_agent_registry)} agent definitions")

        return _agent_registry


def get_agent_definition(agent_id: str) -> Optional[AgentDefinition]:
    """
    Get an agent definition by its agent_id.

    Args:
        agent_id: The agent identifier (e.g., "gene_validation")

    Returns:
        AgentDefinition or None if not found
    """
    if not _initialized:
        load_agent_definitions()

    return _agent_registry.get(agent_id)


def get_agent_by_folder(folder_name: str) -> Optional[AgentDefinition]:
    """
    Get an agent definition by its folder name.

    Args:
        folder_name: The folder name (e.g., "gene")

    Returns:
        AgentDefinition or None if not found
    """
    if not _initialized:
        load_agent_definitions()

    return _agents_by_folder.get(folder_name)


def get_agent_by_tool_name(tool_name: str) -> Optional[AgentDefinition]:
    """
    Get an agent definition by its supervisor tool name.

    Args:
        tool_name: The tool name (e.g., "ask_gene_specialist")

    Returns:
        AgentDefinition or None if not found
    """
    if not _initialized:
        load_agent_definitions()

    for agent in _agent_registry.values():
        if agent.tool_name == tool_name:
            return agent

    return None


def list_agents(
    enabled_only: bool = False,
    category: Optional[str] = None,
) -> List[AgentDefinition]:
    """
    List all loaded agent definitions.

    Args:
        enabled_only: Only return agents with supervisor_routing.enabled=True
        category: Filter by category (e.g., "Validation", "Extraction")

    Returns:
        List of AgentDefinition objects
    """
    if not _initialized:
        load_agent_definitions()

    agents = list(_agent_registry.values())

    if enabled_only:
        agents = [a for a in agents if a.supervisor_routing.enabled]

    if category:
        agents = [a for a in agents if a.category == category]

    return agents


def get_supervisor_tools() -> List[Dict[str, Any]]:
    """
    Get tool metadata for all supervisor-enabled agents.

    Returns a list of tool definitions that can be used to build
    the supervisor's dynamic tool list.

    Returns:
        List of tool metadata dicts with keys:
        - tool_name: e.g., "ask_gene_specialist"
        - description: From supervisor_routing.description
        - batchable: Whether agent handles batch requests
        - batching_instructions: How to format batch requests
        - agent_id: The agent's identifier
    """
    if not _initialized:
        load_agent_definitions()

    tools = []
    for agent in _agent_registry.values():
        if not agent.supervisor_routing.enabled:
            continue

        tools.append({
            "tool_name": agent.tool_name,
            "description": agent.supervisor_routing.description,
            "batchable": agent.supervisor_routing.batchable,
            "batching_instructions": agent.supervisor_routing.batching_instructions,
            "agent_id": agent.agent_id,
        })

    return tools


def is_initialized() -> bool:
    """Check if agent definitions have been loaded."""
    return _initialized


def reset_cache() -> None:
    """Reset the agent cache (for testing)."""
    global _agent_registry, _agents_by_folder, _initialized
    _agent_registry = {}
    _agents_by_folder = {}
    _initialized = False
